1. volatile

   1. 什么是volatile

      > volatile是java从语言上保证了共享变量的可见性。可见性是指，当有一个线程修改一个共享变量时，另一个变量能读到修改的值

   2. 怎么保证可见性（插入cpu指令 lock指令）

      > 禁止指令重排
      >
      > 强制将修改的值写入主存
      >
      > 会导致其他cpu缓存的值失效

2. synchronized

   1. 定义

      > synchronized是对某个对象执行加锁操作

   2. 锁升级

   3. 为什么jdk15放弃偏向锁

3. final

   > 1. JMM禁止编译器把final域的写重排序到构造函数之外；
   > 2. 编译器会在final域写之后，构造函数return之前，插入一个storestore屏障（关于内存屏障可以看[这篇文章](https://juejin.cn/post/6844903600318054413)）。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。

4. sleep和wait的区别

   > sleep()方法是Thread的静态方法，而wait是Object实例方法
   >
   > wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
   >
   > sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。

5. AQS

6. 线程池

