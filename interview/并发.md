1. volatile（b站马士兵）

   1. 什么是volatile

      > volatile是java从语言上保证了共享变量的可见性。可见性是指，当有一个线程修改一个共享变量时，另一个变量能读到修改的值

   2. 怎么保证可见性（插入cpu指令 lock指令）

      > 禁止指令重排
      >
      > 强制将修改的值写入主存
      >
      > 会导致其他cpu缓存的值失效
      
   3. 单核cpu还有必要时用volatile吗

      > volatile不只是要保证其修饰变量的可见性，还要保证该变量之前的共享变量的可见性。因此，在单核机器上，volatile还是有其存在的意义的，就是要禁止重排序，如果不用volatile，单核的情况下依然存在重排序，重排序的结果就是你得不到你想要的结果

2. happen-before原则

3. synchronized

   1. 定义

      > synchronized是对某个对象执行加锁操作

   2. 锁升级

      1. 偏向锁
      2. 轻量级锁
      3. 重量级锁

   3. 为什么jdk15放弃偏向锁

4. final

   > 1. JMM禁止编译器把final域的写重排序到构造函数之外；
   > 2. 编译器会在final域写之后，构造函数return之前，插入一个storestore屏障（关于内存屏障可以看[这篇文章](https://juejin.cn/post/6844903600318054413)）。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。

5. sleep和wait的区别

   > sleep()方法是Thread的静态方法，而wait是Object实例方法
   >
   > wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
   >
   > sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。

6. AQS

7. hashMap

8. concurrentHashMap

9. Sync

   1. 公平锁
   2. 非公平锁

10. 线程池

   11. 线程池执行过程

   12. 自定义异常策略

13. ConcurrentHashMap

14. ReadWriteLock

15. 复习

    1. 怎么新建一个线程
       1. 执行一个Thread对象的start方法
       2. 怎么定义线程的执行逻辑
          1. 重新thread的run方法：因为Thread实现了Runnable接口
          2. 新建一个Runnable，重写run方法（在这里面实现执行逻辑）：因为Thread内部有一个Runnable对象
          3. 新建Callable，重写call方法（在这里面实现执行逻辑），把callable传给FutureTask（futureTask也实现了Runnable接口），把futureTask传给thread：因为runnable没有返回值。里面的runner线程就是执行FutureTask的线程
    2. sleep和wait的区别
       1. wait会释放锁，sleep不会
       2. 调用intercepe方法后，wait会抛出异常，sleep也会
       3. synchronized（obj）if(){obj.wait(0)}: if必须换成while。因为获取锁之后还需要去判断是否满足要求。
       4. wait方法只释放当前共享变量的锁

    

