1. jvm 的结构（加载class文件、管理内存、java程序的执行）

   > 1. 类加载器
   > 2. 运行时数据区（程序计数器，堆、栈、方法区、直接内存）
   >    1. 程序计数器：线程私有，记录当前线程要执行的下一条指令的地址。如果是本地方法，计数器的值为undefined
   >    2. 堆
   >    3. 栈
   >    4. 方法区
   >    5. 直接内存
   > 3. 执行引擎、本地方法库

2. 什么时候进行类加载

   > 1. new 
   > 2. 执行静态方法
   > 3. 执行静态字段
   > 4. 反射
   > 5. 子类加载出触发父类的加载
   > 6. main方法

3. gc（管理内存：哪些内存需要回收、什么时候回收、怎么回收（用什么算法回收），给对象分配内存）

   1. gc做的三件事：分配内存、确保还在使用的对象的内存一直在，不能回收、释放不再使用的的对象占用的内存

   2. gcRoot

      1. 栈帧中的本地变量表引用的对象
      2. 类静态属性引用的对象
      3. 方法区中常量引用的对象
      4. jni引用的对象
      
   5. jvm的内部引用，比如说基本类型对应的class对象，各种异常，系统类加载器
      
      6. 被同步锁（synchronized）持有的对象
      
   7. jmxBean、本地代码缓存
   
   8. 对于youngGC，老年代的对象对新生代的引用可以当做GC Root，反之不行
   
   5. jvm的oopMap（hotspot的叫法）
   
      1. oopmap是一个附加的东西，告诉程序栈（本地变量表）中的哪个位置是什么东西，这个oopmap是编译时和机器码一起产生的。每个方法都会有好几个oopMap，根据方法内的safepoint把一个方法分成几段，每一段代码都有一个oopMap，作用域也仅限于这一段代码
   2. safepoint：循环的末尾，方法返回前，可能抛异常的位置
   
3. 对于jni方法，不是有jvm解释执行，不会生成oopMap，是通过扫描引用的点句柄（变量指向句柄，句柄指向对象）来进行gc
   
6. 分代垃圾回收基于weak generational hypothesis(弱分代假设)
   
      1. 弱分代假设
      
      > 1. 大分部对象都是短命的，生命周期很短
      > 2. 极少数老年对象对年轻对象的引用（老年代到新生代的引用可以视为GCroot，新生代到老年代的引用直接无视）
   
7. hotspot的对象布局
   
      1. 对象的内存布局分为以下三个区域
      
         > * 对象头
         >   * markword 8字节 （hashCode、gc年龄、锁状态标志，线程持有的锁）
         >   * class对象指针 8字节
         >   * 数组长度（只有数组才有）4字节
      > * 实例数据
      > * 内存对齐
   
   8. 什么样的类需要被回收
   
      1. 该类的所有对象都已经被清除
   2. 加载该类的 ClassLoader 已经被回收
   
   3. 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
      
   9. cms垃圾回收器
   
      1. cms只会回收老年代的内存，而且使用的是标记-清除算法，不过可以进行压缩整理
         1. -XX:+UseCMSCompactAtFullCollection： 每次都进行压缩
         2. -XX:CMSFullGCsBeforeCompaction ：多少次full gc够进行压缩
      2. 清理过程
         1. 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。
         2. 并发标记：使用**多条**标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。
   3. 重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。
   
4. 并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。
   
10. G1
   
    1. 概述：
      
       > **从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片**
      
    2. 一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？
      
          > 并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历
      
       3. 回收过程
       
          > - 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。
          > - 并发标记：使用**一条**标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。
    > - 最终标记：Stop The World，使用多条标记线程并发执行。
    
          > - 筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。
   
   11. 内存分配策略
   
       1. 栈上分配：开启逃逸分析 有的变量会被打散 进行标量替换
       2. TLAB(thread local allcation buffer)：堆是共享内存，为了提高多个线程分配内存的效率，会给每个线程分配一块缓冲区，这个缓冲区只允许一个线程分配，分配出来的对象还是线程共享的（提高效率，防止线程之间的竞争）
       
 3. eden：指针碰撞或空闲列表
    
4. 老年代： 大对象直接进入老年代
   
12. 新生代对象晋升条件
   
    1. 长期存活的对象进入老年代：妹进行一次YGC，对象年龄都会加1，-XXMaxTenuringThreshold 设置晋升年龄
      
       2. 动态年龄判断：如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 >= 该年龄的对象就可以直接进入老年代，无须等到 `MaxTenuringThreshold` 中要求的年龄。
       
       3. 空间分配担保：
       
          > 在发生**Minor GC**之前，虚拟机会检查**老年代最大可用的连续空间**是否**大于新生代所有对象的总空间**，
          >
       > 　　　　如果大于，则此次**Minor GC是安全的**
       >
          > 　　　　如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。
   
   13. 什么情况下发生fullGC
   
       1. 手动调用System.gc
       2. 老年代空间不足
       3. 方法区空间不足
       4. minorGC晋升到老年代的平均大小大于老年代的剩余空间
       
   14. ASM
   
   15. 复习

          1. 垃圾回收算法
          2. 垃圾回收器
          3. jvm内存魔属性
          4. oom种类
          5. jvm调优
          6. 类加载过程
             7. 双亲委派机制



