1. jdk

   1. nio
      1. 三大组件？
      2. epoll原理？和select的区别？边缘触发和水平触发？惊群问题？
      3. nio空轮训bug？netty怎么解决？
   2. 集合
      1. set和list区别？

         > set:无序 ，不可重复，时间复杂度（插入：O（1），contain：O（1））
         >
         > list：有序，可重复，list可用过下标来访问，时间复杂度（插入：O（n），contain：O（n））

      2. ArrayList扩容机制？

         > 

      3. ArratList和Vertor区别？

         > ArrayList: 线程不安全，扩容时1.5倍扩容
         >
         > Vertor: 线程安全，扩容时翻倍扩容

      4. ArrayList和LinkedList区别？

         > ArrayList:
         >
         > LinkedList:

      5. Hashmap、hashTable和hashSet区别？

      6. HashMap
         1. put流程？

            > 1. 现在entry数组有没有初始化，如果没有就初始化
            > 2. 计算参数key的hash，算出该key应该在数组中的位置
            > 3. 拿到该位置的node，

         2. 扩容流程？

         3. hashMap的长度为什么是2的幂次方？

            1. 计算数组下标时可以把取余运算转换成位运算
      2. 扩容比较快，高一位为0位置不变，高一位为1的位置=（当前位置+原始数组长度）。整个过程不用重新计算hash值
         
   4. 为什么要把hashCOde右移16位？
         
         1. 扰动函数：使高位也能干扰hash值，增加了随机性
         
         5. 并发安全？
         
            1. hashmap没有使用任何的锁机制，所以是线程不安全的
            2. 可能造成并发安全的操作：
               1. 一写多读
               2. 扩容
         
      7. ConcurretnHashMap
      
      8. CopyOnWriteList
      
      9. jdk新特性
         1. 1.8的新特性
            1. lamdba
            2. 接口的deafult方法
            3. stream
            4. localDatetime
            5. Optional
            6. 独占缓存行注解
         2. jdk9特性
         3. jdk15特性：
            1. 去除synchronized的偏向锁

2. jvm

   1. jvm的内存结构？

      > 1. 类加载器：url 
      > 2. 运行时数据区：
      > 3. 执行引擎，本地方法库

   2. 对象创建过程？

      > 1. 如果开启了逃逸分析，会分析该变量是不是线程私有的，如果是私有的会尝试标量替换把对象打散，把其中的基础数据类型在栈上分配。
      > 2. 如果不能在栈上分配，会尝试在TLAB(thread local aclcation buffer：默认大小是eden区的1%)上分配。（Tlab是为了加快对象分配速度，防止每次分配对象都需要cas，每个TLAB只能由一个线程创建对象，但是创建出来的对象是共享的）
      > 3. 如果TLAB分配失败，如果内存是规整的就进行指针碰撞，否则就在空闲列表找一块内存分配。

   3. 什么情况发生OOm异常

      > 1. 内存泄漏
      > 2. 内存不够

   4. 判断对象是否是垃圾？

      > java里使用可达性算法，从GC ROOTS出发，能被GC ROOTS找到的对象就是存活的对象，否则就是垃圾对象

   5. 怎么判断一个类是无用的类

      1. 该类的所有实例都已经被回收，即java堆中不存在该类的实例
      2. 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
      3. 该类的classLoader已经被回收

   6. GC ROOT

      > 1. 虚拟机栈引用的对象
      > 2. 方法区类属性（static修饰的）引用的对象
      > 3. 方法区常量池引用的对象
      > 4. 本地方法栈中引用的对象
      > 5. 被同步锁（synchronized）持有的对象
      > 6. jvm自身只有的对象，比如系统类加载器，基本数据类型对应的class对象
      > 7. 对于YGC，老年代对新生代的引用也可以作为GC ROOT

   7. 4中引用？

      > 1. 强引用：一般就是new出来的对象
      > 2. 软引用（对应SoftRefenerce）：只要内存足够，就不会被回收。软引用可以配合ReferenceQueue一起使用（在创建软引用的时候在构造方法传入一个ReferenceQueue），当软引用已经被回收时，会把该对象加入ReferenceQueue，调用ReferenceQueue.poll()可以知道哪些软引用会被回收。用来做缓存
      > 3. 弱引用（对应WeekRefenerce）：下次垃圾回收就会回收。也可以配合ReferenceQueue一起使用
      > 4. 虚引用（对应platformRefenerce）：一定要配合ReferenceQueue一起使用。jdk8的platformRefenerce不会对gc产生影响。
      > 5. FinalReference:  如果某个对象实现了非空的Finalize()方法，那么会在编译时候生成一个Finalizer。所有的此类对象形成一个Finalizer链条。在gc的时候会取出对象执行finalize方法，并把该Finalizer从链条中删除，所以finalize方法只会执行一次（单独的线程执行）。

   8. PhantomReference和finalizer：

      1. ![image-20211030155536917](image-20211030155536917.png)-
      2. -------------------------------------------------------------------------------- ![image-20211030155618428](image-20211030155618428.png)

   9. 软引用为什么可以解决OOM问题？

      > ​	假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。
      >
      > 　设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。

   10. 虚引用的作用？

      > 1. 之前mysql使用finalize方法来清理资源，先已经改为虚引用了（finalize线程可能得不到执行，导致无法gc）

   11. 为什么jdk的垃圾回收不回收 虚引用？

       > ​    在Java 8的实现中，确保对象在真正GC前能被对应的ReferenceQueue处理，所以将对象标记为活跃，不回收对象
       >
       > ​    显然，在这种情况下，会导致本可以回收的对象无法回收的问题，所以在Java 9中，确保PhantomReference指向的对象在回收后（而不是原来的回收前），会被对应的ReferenceQueue处理，这样在一定程度上保证了功能，又修复了这个问题

   12. 方法区的回收？

   13. 垃圾回收算法？

       > 1. 标记清楚：
       > 2. 复制算法：
       > 3. 标记整理算法：

   14. 内存分配和回收策略？

       1. 对象分配原则

          > 1. 栈上分配->TLAB->eden分配，如果eden没有足够的空间，执行Minor GC
          > 2. 大对象直接进入老年代：

       2. 回收策略

   15. 对象怎么进入老年代？

       > 1. 大对象直接进入老年代
       > 2. 长期存活的对象进入老年代
       > 3. 动态年龄判断：如果survivor区中相同年龄的对象大于survivor空间的一般，那么大于该年龄的对象进入老年代
       > 4. 空间担保：每次进行GC时，jvm会计算survivor区移到老年代对象的平均大小，如果这个值大于老年代的剩余空间则进行一次full GC

   16. 垃圾回收器？

       1. ![image-20211101113111655](image-20211101113111655.png)
       2. asdf

   17. G1

   18. CMS

       1. 初始标记：需要stw，只标记GC ROOT能直接关联的对象
       2. 并发标记：在初始标记的基础上继续搜索
       3. 预清理：
       4. 可被终止的预清理：
       5. 重新标记：
       6. 并发清除：
       7. 并发重置状态

   19. zgc

   20. 三色标记法？浮动垃圾？

       1. 把从GC ROOTS开始遍历到的对象按“是否访问过”标记成3中颜色

          > * 白色：没被访问过
          > * 黑色：本对象已访问过，而且本对象引用的其他对象也全部访问过了
          > * 灰色：本对象已访问过，但是本对象引用的其他对象没有全部访问完。全部访问完后，会变成黑色

       2. 遍历访问过程

          > 假设现在有白色、灰色、黑色三个集合，分别存放对应颜色的对象
          >
          > 1. 开始垃圾回收时，所有的对象都在白色集合中
          > 2. 将GC ROOTS直接引用的对象挪到灰色集合汇中
          > 3. 从灰色集合中获取对象
          >    1. 将本对象引用到的其他对象挪到灰色集合中
          >    2. 将本对象挪到黑色集合中
          > 4. 重复步骤3，知道灰色集合为空
          > 5. 此时仍在白色集合的对象就是垃圾，在黑色集合的对象就是存活下来的对象

       3. 当需要支持并发标记时（标记期间，应用程序还在继续跑 继续产生垃圾），对象间的引用关系可能发生变化，多标和漏标的情况就会发生

          1. 多标（浮动垃圾）：

             > 在并发标记期间，有些对象由GC ROOTS可达变成了不可达。这部分是本应该回收但是却没有被回到到的内存。下一次垃圾回收会回收这些对象

          2. 漏标：

       4. 各个垃圾回收器对漏标的处理办法：

          1. CMS:写屏障+增量更新
          2. G1:写屏障+SATB
          3. zgc:读屏障

   21. 分代收集？弱分代假设？分代收集垃圾回收器怎么工作？

       > 1. 弱分代假设的两个理论
       >    1. 大部分对象都是朝生夕死的
       >    2. 少部分年级大的对象持有年纪小的对象的引用
       > 2. 分代收集是弱分代理论1，有了分代之后就只需要在新生代进行频繁GC，提高了收集效率
       > 3. 如果没有分代收集，新创建的对象和生命周期很长的对象放在一起，由于程序在不断运行会产生大量垃圾，所以每次回收都需要遍历所有对象，扫描整个堆空间，会严重影响程序效率，而且效率不高

   22. 类加载过程？类加载方式？tomcat如何破坏双亲委派模型？

       > 1. 类加载就是把class文件加载到内存
       > 2. 双亲委派
       >    1. 先交给父加载器加载
       >    2. 加载：类加载器扫描自己的url下的类，转化成路劲，然后加载类的二进制数据
       >    3. 验证：验证文件格式，字节码等
       >    4. 准备：为类的静态变量分配内存，并初始化成为默认值
       >    5. 解析：把符号引用（就是个字符串）装换为直接引用（可以是直接指向目标的指针（指向对象、类变量、类方法的指针），相对偏移量（指向实例变量方法的指针）或是句柄）
       >    6. 初始化：给类的静态变量赋予正确的值，执行静态代码块等

   23. new Object（）发生了什么？

       1. 先去检查该类是否被加载了，没有就使用双亲委派进行类加载
       2. 加载->验证->准备->解析->初始化
       3. 栈上分配或分配内存：栈->TLAB->(空闲列表或指针碰撞)
       4. 初始化（实例变量初始化零值）->设置对象头->执行init方法、构造方法

   24. 什么情况发送ygc？什么情况下发送full gc？

       1. ygc

          > 1. Eden区满了

       2. full gc

          > 1. 手动执行System.gc（没有手动禁用GC的前提下）。部分垃圾回收器会执行Full GC
          > 2. 堆伸缩时会发生full gc：
          > 3. 老年代空间不足：大对象进入老年代、长期存活的对象进入老年代
          > 4. metaSpace空间不足：比如使用了OSGI动态生成了大量的类
          > 5. 空间担保：
          >    1. 每次晋升对象的平均大小>老年代剩余空间
          >    2. minor GC后存活的对象超过了老年代的空间

   25. jvm怎么调优？一般从哪里入手？

       1. 调优的策略：尽量把生命周期短的对象留在新生代，减少对象进入老年代的机会，生命周期长的对象放在老年代

   26. 为什么有垃圾回收还会发生内存泄漏？

       > java里的内存泄漏是指 已经不用的对象长期占用着内存或者说生命周期短的对象长期在内存中。
       >
       > 内存泄漏原因：1. 一般是对象的作用域设置的不合理
       >
       > ​							2. 不用的对象没有手动置为 null

   27. 内存持续上升？怎么定位问题？

       1. 内存泄漏
       2. 如果不是内存泄漏，说明对象过早的进入了老年代，过早进入老年代的原因：
          1. 对象晋升年龄过低
          2. 程序创建了大对象、大数组
          3. 空间担保导致对象进入了老年代
          4. 动态年龄判断导致对象过早进入老年代

   28. jvm参数？

       1. -Xms：最小堆内存
       2. -Xmx：最大堆内存
       3. -XX:NewSize：新生代大小
       4. -XX:NewRatio: 新生代和老年代的比例（最小值为1）
       5. -XX：SurvivorRatio：eden和survivor的比例（最小值为1）

3. juc

   1. 多线程理解？什么是并发安全？

   2. java实现同步方式？

   3. 如何创建一个线程？如何指定线程的执行逻辑？

   4. 线程的6种状态？

   5. 对象头？每个对象占多大内存？markWord？monitor？

   6. volatile？

      1. 可见性和有序性怎么保证？

      2. 缓存一致性协议怎么保证可见性？

         > 1. cpu的缓存值有4个状态：独占，共享，已修改，失效
         > 2. 当状态是共享转为已修改时，会通知其他cpu，使其他cpu缓存的值变成失效

   7. synchronized

      1. 锁升级？偏向锁->自旋锁->重量级锁

         > 1. 线程第一次获取锁的时候，

      2. jdk15为什么去掉偏向锁？

         > 水电费

      3. synchronized怎么保证可重入性？

         > synchronized锁住对象的时候会有个计数器，记录了持有锁的线程获取锁的次数，执行完synchronize代码块之后，该计数器就会-1，如果计数器为0，那么就释放锁了。

      4. synchronize抛出异常会怎么样？

         > synchronized重入之后，内层抛出异常，跳出synchronized代码块，会释放锁

   8. volatile和synchronized的区别？

   9. lock和synchronized的区别？

   10. 并发容器和同步容器

       1. 同步容器：
       2. 并发容器：

   11. 什么是死锁？

       > 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源造成的一种互相等待的现象，若无外力干扰，他们都无法继续执行下去。

   12. 死锁发生的原因？

       > 1. 系统资源不足
       > 2. 进程运行获取资源的顺序不合理
       > 3. 资源分配不当

   13. 死锁发生条件

       > 1. 互斥条件：一个资源每次只能被一个进程使用。
       > 2. 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
       > 3. 不可强行占有：进程（线程）已获得的资源，在未使用完之前，不能强行剥夺。
       > 4. 循环等待条件：若干进程（线程）之间形成一种头尾相接的循环等待资源关系。

   14. Java死锁怎么排查和解决？

       > 1. 是用arthas的thread -b可以找出当前阻塞其他线程的线程

   15. cpu100%怎么排查和解决？

   16. Java的内存模型？

   17. as-if-serial?

   18. final？

   19. aqs

   20. threadLocal

   21. fastThreadLocal

   22. 线程池

       1. 七个核心参数？

          > 1. ThreadFactory:
          > 2. coreSize:
          > 3. queue:
          > 4. maxSize:
          > 5. RejectPolicy:
          > 6. TimeUnit:
          > 7. time:

       2. 线程池的锁？

       3. 自定义拒绝策略？

          > 序列化 然后保存起来

5. 计网

   1. http
   2. tcp
   3. udp
   4. http和https的区别？
   5. 对称加密和非对称加密？
   6. http请求和响应报文格式？
   7. http常见状态码和请求头?
   8. 长连接和短连接？
   9. redis session共享？
   10. http only？
   11. http1.1新特性？
   12. http2.0新 特性？dubbo使用http2
   13. restful？幂等？
   14. post和get区别？
   15. https连接过程
   16. 
   17. 浏览器输入一个域名发生了什么？
       1. 解析域名
       2. tcp连接
       3. ssl连接
       4. 发送请求
       5. nginx->web
       6. 解析请求

5. spring

   1. 为什么spring不同class来建立bean，而要用beanDefinition？

      > 

   2. bean的生命周期？

      1. 生命周期图：![image-20211101202059474](image-20211101202059474.png)
      2. 注意：spring只帮助我们管理singleton的bean的生命周期。对于prototype的bean，spring在创建好了bean之后就不会再管理其生命周期了

   3. bean的scope？

      > 在spring context中只定义了singleton和prototype两个scope
      >
      > 在spring web中新增了request session等scope

   4. 静态代理和动态代理的区别？

      1. 静态代理：

         > 1. 需要硬编码，而且要为每个需要被代理的类生成其实现，扩展性不高 但是性能高

      2. 动态代理：

         > 1. 

   5. jdk动态代理和cglib动态代理的区别？

      1. jdk动态代理

         > 被jdk代理的对象必须实现接口

      2. cglib动态代理

         > 被cglib代理的对象的方法不能是final，因为cglib是通过继承的方式来增强的

   6. spring 默认 用什么代理？

      > spring framework默认使用jdk动态代理
      >
      > 但是spring boot默认使用cglib动态代理

   7. ioc的初始化过程？

   8. beanFactory和applicationContext那个才是ioc容器？

      > beanFactory: 定义了ioc容器最基础的功能
      >
      > applicationContext：实现了beanFactory接口，不过对于beanFactory的接口方法都是委托给DefaultListableBeanFactory来实现的。除此之外，添加了额外的功能（国际化，事件驱动）。

   9. 三级缓存怎么实现？怎么解决循环依赖

      > asdf

   10. spring aop的理解？基本概念？

   11. spring aop实现原理？

   12. @Qualifier注解？

   13. spring mvc流程？

   14. spring boot自动装配原理？

   15. spring boot怎么实现热部署？

   16. spring 事务实现方式？

       1. 编程式事务
       2. 声明式事务 
          1. 使用@Transactional注解

   17. 事务传播级别？？

   18. spring用了哪些设计模式

       1. 单例：spring的bean默认就是单例的
       2. 工厂模式：使用工厂模式创建bean

   19. 

   20. 源码？
       1. spring session源码
          1. MapSession.getId(): 产生一个UUID作为session

7. kafka

   1. kafka为什么这么快？

   2. 零拷贝？

      1. 存储消息使用mmap：内核和程序的虚拟地址映射为同一个物理地址
      2. poll消息使用sendFile：数据对应用程序不可见

   3. kafka的日志段如何读写？

   4. kafka的消息是推还是拉，怎么实现的？

      > 由kafkaConsumer自己拉

   5. 怎么保证消息不丢失？

      > 

   6. 如何处理重复消息？

   7. 消息的有序性？

   8. 消息的堆积处理？

   9. kafka的主题与分区内部是如何存储的，有什么特点？

   10. 与传统的消息系统相比，kafka的消费模型有什么优点？

   11. kafka如何实现分布式的数据存储与数据读取？

   12. 索引

       1. 什么是稀疏索引？和密集索引的关系以及区别

          > 

       2. kafka的索引是稀疏索引，主要有三类

          1. 时间戳索引
          2. 位移索引
          3. 事务索引

   13. 源码？

7. mysql

   1. 三大范式？

      > 一范式：所有属性都不可分割
      >
      > 二范式：在一范式的基础上，消除了属性对非住属性的依赖
      >
      > 三范式：在二范式的基础上，消除了传递依赖

   2. 一条select语句的执行过程？

      > 

   3. 一条update sql执行过程？

      1. 连接器：
      2. 分析器：
      3. 优化器：memory存储引擎
      4. 执行器：
      5. innodb：buffer pool

   4. innodb和myisam的区别？

      1. 事务：
      2. 外键：
      3. 索引：inndob存储数据是聚簇索引，主键和数据放在一起。myisam的索引和数据是分开的
      4. 日志：innodb有redo log和undo log
      5. count：
      6. 锁：innodb支持行锁、表锁，而myisam只支持表锁
      7. 存储文件：innodb有两个文件：frm是表定义文件，idb是数据文件。myisam有三个文件：frm是表定义文件，myd是数据文件，myi是索引文件
      8. 插入顺序：innodb插入的数据会按主键排序（会导致页分裂），myisam数据的存放顺序和插入顺序一致
      9. 二级索引：innodb的二级索引存的是主键，myisam的索引存的是数据页的地址

   5. myisam查询为什么比innodb快？

      > 1. myisam的二级索引存储的是数据的地址，不需要回表
      > 2. myisam不支持事务等特性，不需要记录redo log等日志

   6. innodb的特性？

      1. 插入缓冲

         >   对于索引（该索引是二级索引并且索引不是唯一的）的插入和更新，不是每一次都直接插入到索引页中，而是先插入到内存中。
         >
         >   具体做法：如果该索引页在buffer pool中，直接插入；如果不在就先放到insert buffer中，再以一定的频率和索引页合并。这样就可以把同一个索引页的多个插入合并到一次IO中，大大提高了写性能。有点像LSM树

      2. 二次写

         1. partial page wirte问题

            > innodb的数据页（page size）一般是16KB，将数据写入磁盘也是以page为单位进行操作。但是文件系统对于16kb的操作不是原子性的，会导致16KB的数据有可能只写入了4KB，然后服务器就宕机了，这会造成数据页的损坏。（redo log记录的是数据页的物理修改，例如：偏移量200，写aaa记录。如果数据页已经损坏，redo log是没办法进行恢复的）、

         2. 为什么redo log不会有partial page wirte问题？

            > 因为redolog的写是以4KB为单位写，这个大小的数据页的写入是具有原子性的

         3. 实现原理：

            > 做个冗余，在写数据页之前，先把这个数据页写到一块独立的物理位置，然后再写数据页。这样在宕机重启的时候，如果发生了数据页损坏，那么在使用redolog 重做之前，使用该副本来还原数据页，然后再进行redo重做。二次型保证的是innodb存储引擎数据页的可靠性

      3. 自适应hash

   7. 为什么自增主键不连续？

      > 1. innodb的自增值是保存在内存中的，8.0之后才会持久化。所以当mysql重启之后，第一次打开表都会去找max（id），然后把max（id）+1作为下一次自增的id的值。
      > 2. 插入失败后，id也不会减1
      > 3. 事务回滚后，id不会减1.
      > 4. 为什么这么设计？
      >    1. 为了解决主键冲突，每次申请主键id都需要去加锁，如果加上回滚功能，申请id时需要等到上一个insert事务提交，而且这样锁的粒度太大，系统的插入性能太慢

   8. 自增主键理解？

   9. 为什么innodb必须要有主键？

      > 1. innodb使用的是聚簇索引，数据是挂在主键下面的。所以几乎每次查询都需要利用主键，如果主键是和业务相关的，我们就可以利用到这个主键加快查询速度。

   10. innodb为什么推荐自增id？

       > 1. 如果不是自增，那么数据就有可能从页的中间插入，会频繁导致页分裂，造成性能下降
       >
       > 2. 

   11. 索引
       1. 为什么用b+树

          1. msyql是一个OLTP数据库，需要在短时间内返回数据，数据又是放在磁盘上，所以为了加快查询速度，必须降低IO次数
          2. b+树扇出性高，可以在比较低的层级存储大量的数据
          3. b+树比较稳定
          4. 底层有双向链表，更符合应用场景（范围查询）

       2. 索引类型？

          1. 聚簇索引和非聚簇索引
          2. 全文索引、自适应hash索引、b+树索引

       3. 索引覆盖？回表？索引下推？联合索引？

          1. 索引覆盖：

             > 1. 使用explain输出结果的Extra字段为using index时，表示能触发索引覆盖
         > 2. 只需要在一颗索引树上就能获取到sql所需的所有列数据
             
      2. 索引下推
       
         > mysql5.6的新功能：![image-20211101192354063](image-20211101192354063.png)
             >
         > ![image-20211101192515257](image-20211101192515257.png)
       
   4. 索引失效场景？
       
      1. 使用了函数或者算术表达式
          2. 使用了'LIKIE刘' ,>,<,!=
      3. 发生了类型转换
          4. 不同的字段使用了or：name='' or age=123
          5. not int,not exists
          6. 字段可以为null：使用is null或者is not null可能导致索引失效
          7. 联合索引违背最左匹配原则
       
       5. 最左匹配原则？
       
       6. 联合索引建立规则？
       
       7. 前缀索引？
       
       8. 百万级别数据怎么删除？
       
       9. 普通索引和联合索引怎么选择？
       
   12. 锁

   13. 事务
       1. acid？

       2. mvcc？

          > rr下的mvcc：
          >
          > rc下的mvcc：每次select都会生成一个readView

   14. explain？

   15. 脏页？怎样刷新脏页？

   16. 一条sql很慢怎么定位？

   17. sql优化？

   18. mysql的三种日志？

   19. 什么是撞库、脱库、洗库？

   20. 主从复制？

   21. 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录

   22. 主从一致性校验？

   23. 如何分库分表？

   24. 如何实现跨库分页查询？

   25. 分库分表之后怎么平滑上线？

   26. limit 1000000很慢怎么解决

8. redis

   1. 为什么选择redis？

      1. 快

   2. 5种基本数据结构+redis module+redis stream

      1. redis module提供了一种插件的方式接入我们自定义的数据结构，比如说bloom filter
      2. redis stream是用来替换sub/pub的

   3. redis为什么快？

      1. 基于内存
      2. 单线程，减少了线程切换的消耗
      3. epoll机制
      4. redis存储数据使用hash，读取数据快
      5. redis实现了自己的事件分离器，内部使用了非阻塞的执行方式，吞吐量大

   4. redis渐近式hash?

      1. ![image-20211031192718557](image-20211031192718557.png)
      2. 在渐进式hash过程中，字典会同时使用ht[0], ht[1]两个hash表，字典的删除、查找、更新等操作都会在两个hash表里进行。除此之外，新增的键值对都保存到h[1]中

   5. redis的线程模型？

      1. redis内部使用文件事件处理器（file event handler），这个文件事件处理器是单线程的，所以redis才叫单线程的模型。它采用IO多路复用的机制同时监听多个socket，根据socker的事件来选择对应的事件处理器进行处理
      2. 文件事件处理器的结构包含4部分
         1. 多个socket
         2. IO多路复用程序
         3. 文件事件分派器
         4. 事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）
      3. 多个socket可能会并发产生不同的操作，每个操作对应不同的事件。但是IO多路复用程序会监听多个socket，将socket产生的事件放入队列中排队，事件分派器每次葱队列中取出一个事件，把该事件交给对应的事件处理器进行处理
      4. 流程图：![11224747-5139249680a222cf](11224747-5139249680a222cf.webp)
      5. 流程图2：![image-20211101203726439](image-20211101203726439.png)

   6. redis6.0为何使用多线程？

      1. 为什么之前不适用多线程？

         > 一般来说redis的瓶颈不在cpu，而在于内存和网络。如果要使用多核cpu，可以搭建多个redis实例来解决。

      2. redis在4.0的时候就有多线程的概念了。比如redis通过多线程方式在后台删除对象

      3. 为什么6.0之前一直不使用多线程？

         > 多线程的模型虽然在某些方面变现优异（非阻塞），但是带来了并发读写的问题，增加了系统复杂度，同时也可能存在线程切换、加锁、死锁带来的损耗。

      4. 为什么要6.0引入多线程？

         > redis的瓶颈不在cpu，在内存和网络。
         >
         > 内存可以通过加内存的方式解决或者搭建集群
         >
         > 网络IO的读写在redis执行期间占用了大部分cpu的时间，如果能把网络处理这块引入多线程，对redis的性能有很大提升。

      5. 多线程实现机制：![image-20211101204413300](image-20211101204413300.png)

      6. 特点：

         1. IO线程要么同时在读socket，要么同时在写socket，不会同时读写
         2. IO线程只负责读写socket解析命令，不负责命令处理，所以不会带来并发安全问题

      7. 总结：

         1. 可以充分利用多核cpu，但是主线程还是只能利用一个核
         2. 多线程可以分摊Redis同步读写IO的压力

   7. 缓存过期策略？

      1. 定期删除：

         1. 概念：redis默认每隔100ms（）就随机抽取一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删除。

         2. 为什么是随机部分，而不是全部

            > 

      2. 

   8. 内存淘汰机制？

   9. 主从

   10. 复制流程？

   11. 哨兵

   12. 集群

   13. 选举流程

   14. redis的hash槽？

   15. 集群的最大节点个数？

   16. redis的aof和rdb？

       1. RDB:
          1. 
       2. AOF

   17. redis的事务？

   18. 缓存击穿、雪崩、穿透怎么解决？

   19. watch和cas乐观锁？

   20. redis如何实现分布式锁？

   21. redis的redlock？

   22. 并发竞争？

   23. 异步队列？

   24. 延时队列？

   25. redis如何保证双写一致性？先更新缓存还是先更新数据库

       1. 三个经典的缓存模式：

          1. Cache-Aside Pattern（旁路缓存）

             > 1. 读请求：先查询缓存，命中直接返回数据。没有命中就去数据库取出数据放入缓存。
             > 2. 写流程：先更新数据库，然后再删除 缓存

          2. Read-Through/Write through

             > read: 由cache provider来负责缓存和数据库的读写。先查询缓存，命中直接返回数据。没有命中就去数据库取出数据放入缓存
             >
             > write:更新数据库，然后更新缓存

          3. 在2的基础上使用异步来执行

       2. 为什么是删除缓存而不是更新缓存：

          1. ![image-20211031185058916](image-20211031185058916.png)
          2. 如果写入的缓存值是经过复杂计算得到的，就会造成多次更新，浪费性能
          3. 有可能有的数据在缓存中，还没有被读取到就被跟更新了

       3. 为什么是先操作数据库而不是先操作缓存？

          1. ![image-20211031185325238](image-20211031185325238.png)
          2. 123

       4. 缓存延时双删是什么？

          1. ![image-20211031185428444](image-20211031185428444.png)
          2. 123

       5. 先更新数据库再删除缓存，万一删除缓存失败了怎么办？

          1. 引入消息队列：![image-20211031185702499](image-20211031185702499.png)
          2. 使用数据库的binlog来异步淘汰key：![image-20211031185738410](image-20211031185738410.png)
          3. 123

   26. redis内存耗尽后怎么办？

   27. redis怎么做大数据量的插入？

   28. 如何解决redis的并发竞争key的问题？

   29. 1亿个key，10万个key是已知前缀，怎么把它们全找出来？

   30. mysql有2000w数据，redis只存20w数据，怎么保证redis的数据就是热数据

   31. 如何排查redis性能问题？

   32. redis的hot key？

   33. redis怎么删除大key（指某个key的value很大）？

       > 1. 如果线上redis出现大key，不可立即执行del，因为del会造成阻塞，导致其他请求超时->redis连接池耗尽->依赖redis的业务出现异常
       > 2. 解决方案：
       >    1. 系统负载低的时候

   34. 主库挂怎么办》？

10. dubbo

    1. dubbo支持的协议？
    2. dubbo怎么实现熔断？
    3. dubbo调用过程？
    4. 怎么实现限流？
    5. 序列化实现原理？
    6. dubbo怎么支持事务？
    7. dubbo的负载均衡？

11. 系统设计

    1. 如何设计一个高并发系统？
    2. 需求多变时，怎么设计？
    3. 使用hashMap实现一个带时间的缓存？
    4. 如何设计一个秒杀系统？
    5. java接口设计？
    6. 短连接？
    7. 抢红包？
    8. 扫码登陆？
    9. 延迟队列？
    10. 敏感数据过滤设计？
    11. rpc设计？

12. netty

13. sentinel

14. 分布式

    1. 分布式和微服务的理解？
    2. 为什么要分布式？集群？负载均衡？
    3. cap理论？
    4. paxos和raft？
    5. 分布式事务？
    6. 分布式ID?
    7. rpc？
    8. 一致性hash？
    9. 高可用？限流？降级？熔断？集群？
    10. 限流算法：
        1. 漏桶算法
        2. 令牌桶算法
        3. 滑动窗口
        4. 限流库：
           1. 单机限流：guava
           2. 分布式限流： redis+lua

15. linux

    1. tcpdump抓包过程？
       1. 先查看网卡：ip a | grep
       2. tcpdump -i ens192 -nn host 192.168.3.63 port 5533 -Xs0

16. 其他

    1. 怎么跨线程传递THreadLocal

       > 使用阿里的TTL：对ThreadLocal进行store和relay

    2. 生产者消费者模型？（三种方案）

    3. 如果一个Java进程突然消失了，你会怎么去排查这种问题？

       1. linux的OOM killer

          > 该机制会监控那些占用内存过大的进程，为了防止内存耗尽而把该进程杀掉
          >
          > egrep -i 'killed process' /var/log/messages

       2. jvm自身故障

          > jvm发生致命错误导致崩溃时，会生成一个hs_err_pid_xxx.log文件，默认情况在这个文件在工作目录，也可以指定： -XX:ErrorFile=/var/log/hs_err_pid<pid>.log

    4. 出现大量502怎么解决？